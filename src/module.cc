#include <cassert>
#include <complex>
#include <libqalculate/qalculate.h>

#include "pybind.hh"

#include <pybind11/attr.h>
#include <pybind11/cast.h>
#include <pybind11/complex.h>
#include <pybind11/gil.h>
#include <pybind11/operators.h>
#include <pybind11/pybind11.h>
#include <pybind11/pytypes.h>
#include <pybind11/stl.h>
#include <string_view>

#include "expression_items.hh"
#include "generated.hh"
#include "number.hh"
#include "options.hh"
#include "proxies.hh"
#include "ref.hh"
#include "wrappers.hh"

MathStructureRef calculate(MathStructure const &mstruct,
                           PEvaluationOptions const &options, std::string to) {
  MathStructure result;
  {
    py::gil_scoped_release _gil;
    result = CALCULATOR->calculate(mstruct, options, to);
  }
  return MathStructureRef::adopt(result);
}

PYBIND11_MODULE(qalculate, m) {
  m.doc() = "Python bindings for libqalculate";

  new Calculator();

  // TODO: Properties somewhere?
  m.def("get_precision", []() { return CALCULATOR->getPrecision(); });
  m.def("set_precision",
        [](int precision) { CALCULATOR->setPrecision(precision); });

  add_all_enums(m);

#define DEF_COMPARISON_HELPER(name, macro)                                     \
  .def_property_readonly(name,                                                 \
                         [](ComparisonResult self) { return macro(self); })

  // clang-format off
  // Values are defined in add_all_enums
  add_comparison_result_enum(m)
    DEF_COMPARISON_HELPER("might_be_less_or_greater", COMPARISON_MIGHT_BE_LESS_OR_GREATER)
    DEF_COMPARISON_HELPER("not_fully_known", COMPARISON_NOT_FULLY_KNOWN)
    DEF_COMPARISON_HELPER("is_equal_or_greater", COMPARISON_IS_EQUAL_OR_GREATER)
    DEF_COMPARISON_HELPER("is_equal_or_less", COMPARISON_IS_EQUAL_OR_LESS)
    DEF_COMPARISON_HELPER("is_not_equal", COMPARISON_IS_NOT_EQUAL)
    DEF_COMPARISON_HELPER("might_be_equal", COMPARISON_MIGHT_BE_EQUAL)
    DEF_COMPARISON_HELPER("might_be_not_equal", COMPARISON_MIGHT_BE_NOT_EQUAL);
  // clang-format on

  add_auto_sort_options(m);
  add_auto_print_options(m);
  add_auto_parse_options(m);
  // FIXME: isolate_var is not part of the autogenerated constructor
  add_auto_evaluation_options(m).def_property(
      "isolate_var", &PEvaluationOptions::get_isolate_var,
      &PEvaluationOptions::set_isolate_var);

  repr_print_options.use_unicode_signs = UNICODE_SIGNS_WITHOUT_EXPONENTS;
  repr_print_options.interval_display = INTERVAL_DISPLAY_MIDPOINT;

  auto number = init_auto_number(
      py::class_<Number>(m, "Number")
          .def(py::init<>())
          .def(py::init(&number_from_python_int))
          .def(py::init(&number_from_complex))
          .def(py::init([](long double value) {
            Number number;
            if (value == INFINITY)
              number.setPlusInfinity();
            else if (value == -INFINITY)
              number.setMinusInfinity();
            else if (value == NAN)
              throw py::value_error("NaN cannot be converted into Number");
            else
              number.setFloat(value);
            return number;
          }))

          .def_property_readonly_static("PLUS_INFINITY",
                                        [](py::handle) {
                                          Number number;
                                          number.setPlusInfinity();
                                          return number;
                                        })

          .def_property_readonly_static("MINUS_INFINITY",
                                        [](py::handle) {
                                          Number number;
                                          number.setMinusInfinity();
                                          return number;
                                        })

          .def(
              "print",
              [](Number const &self, PrintOptions const &options) {
                return self.print(options);
              },
              py::arg("options") = &global_print_options, py::pos_only{},
              py::is_operator{})

          .def("__int__", number_to_python_int)
          .def("__float__", number_to_python_float)
          .def("__complex__", number_to_python_complex)

          .def(
              "__repr__",
              [](Number const &self) { return self.print(repr_print_options); },
              py::is_operator{})

          .def(-py::self)

          .def(
              "__eq__",
              [](Number const &self, Number const &other) {
                // Compare infinities as equal by default
                return self.equals(other, false, true);
              },
              py::is_operator{}));

  py::implicitly_convertible<long double, Number>();
  py::implicitly_convertible<std::complex<long double>, Number>();
  py::implicitly_convertible<py::int_, Number>();

#define DEF_PROXY_CONVERSION(from_type, proxy)                                 \
  def(py::init(                                                                \
      [](from_type value) { return MathStructureRef(new proxy(value)); }))

  auto math_structure_cls =
      qalc_class_<MathStructure>(m, "MathStructure", py::is_final{});

  add_expression_name(m);
  add_expression_item(m);
  add_assumptions(m);
  add_variable(m).def(py::init([](MathStructureVariableProxy const &m) {
                        return QalcRef(m.variable());
                      }),
                      py::arg("math_structure"), py::pos_only{},
                      py::return_value_policy::reference_internal);
  add_unknown_variable(m);
  add_math_function(m);
  add_builtin_functions(m);
  add_unit(m);

  py::implicitly_convertible<py::int_, MathStructure>();
  py::implicitly_convertible<long double, MathStructure>();
  py::implicitly_convertible<std::complex<long double>, MathStructure>();
  py::implicitly_convertible<py::list, MathStructure>();
  py::implicitly_convertible<Variable, MathStructure>();
  py::implicitly_convertible<MathFunction, MathStructure>();

  // FIXME: Clean this up finally...
  add_math_structure_proxies(init_math_structure_children(
      m, init_auto_math_structure(
             math_structure_cls
                 .DEF_PROXY_CONVERSION(py::int_, MathStructureNumberProxy)
                 .DEF_PROXY_CONVERSION(long double, MathStructureNumberProxy)
                 .DEF_PROXY_CONVERSION(std::complex<long double>,
                                       MathStructureNumberProxy)
                 .DEF_PROXY_CONVERSION(py::list, MathStructureVectorProxy)
                 .DEF_PROXY_CONVERSION(QalcRef<Variable>,
                                       MathStructureVariableProxy)
                 .DEF_PROXY_CONVERSION(QalcRef<MathFunction>,
                                       MathStructureFunctionProxy)

                 .def("compare", &MathStructure::compare)
                 .def("compare_approximately",
                      &MathStructure::compareApproximately)

                 .def("calculate", &calculate,
                      py::arg("options") = &global_evaluation_options,
                      py::arg("to") = "")

                 .def(
                     "print",
                     [](MathStructure &s, PrintOptions const &options) {
                       return s.print(options);
                     },
                     py::arg("options") = &global_print_options)

                 .def(
                     "__eq__",
                     [](MathStructure const &self, MathStructure const &other) {
                       // Compare infinities as equal by default
                       return self.equals(other, false, true);
                     },
                     py::is_operator{}))));

  number.def(py::init([](MathStructureNumberProxy const &structure) {
    return structure.number();
  }));

  py::implicitly_convertible<Variable, MathStructureVariableProxy>();
  py::implicitly_convertible<MathStructureVariableProxy, Variable>();
  py::implicitly_convertible<MathFunction, MathStructureFunctionProxy>();

  m.def("get_message_print_options",
        []() { return CALCULATOR->messagePrintOptions(); });

  m.def("set_message_print_options",
        [](PrintOptions &opts) { CALCULATOR->setMessagePrintOptions(opts); });

  m.def("calculate", &calculate, py::arg("expression"), py::pos_only{},
        py::arg("options") = &global_evaluation_options, py::arg("to") = "");

  m.def(
      "parse",
      [](std::string_view s) {
        return MathStructureRef::adopt(CALCULATOR->parse(std::string(s)));
      },
      py::arg("value"), py::pos_only{});

  m.def(
      "calculate",
      [](std::string expression, PEvaluationOptions const &options,
         std::string to) {
        return calculate(CALCULATOR->parse(expression, options.parse_options),
                         options, to);
      },
      py::arg("expression"), py::arg("options") = &global_evaluation_options,
      py::arg("to") = "");

  m.def(
      "calculate_and_print",
      [](std::string expression, PEvaluationOptions const &eval_options,
         PrintOptions const &print_options) {
        py::gil_scoped_release _gil;
        std::string result = CALCULATOR->calculateAndPrint(
            expression, -1, eval_options, print_options);
        assert(!CALCULATOR->aborted());
        return result;
      },
      py::arg("expression"),
      py::arg("eval_options") = &global_evaluation_options,
      py::arg("print_options") = &global_print_options);

  py::class_<CalculatorMessage>(m, "Message")
      .def_property_readonly("text", &CalculatorMessage::c_message)
      .def_property_readonly("type", &CalculatorMessage::type);

  m.def("take_messages", []() {
    std::vector<CalculatorMessage> messages;
    while (true) {
      CalculatorMessage *msg = CALCULATOR->message();
      if (!msg)
        return messages;
      messages.emplace_back(std::move(*msg));
      CALCULATOR->nextMessage();
    }
  });

  auto loaders =
      std::initializer_list<std::pair<char const *, bool (Calculator::*)()>>{
          {"load_global_prefixes", &Calculator::loadGlobalPrefixes},
          {"load_global_currencies", &Calculator::loadGlobalCurrencies},
          {"load_global_units", &Calculator::loadGlobalUnits},
          {"load_global_variables", &Calculator::loadGlobalVariables},
          {"load_global_functions", &Calculator::loadGlobalFunctions},
          {"load_global_dataSets", &Calculator::loadGlobalDataSets},
      };
  for (auto loader : loaders)
    m.def(loader.first, [loader] {
      if (!(*CALCULATOR.*loader.second)())
        throw std::runtime_error("qalculate failed to load something");
    });

#define MAKE_GLOBAL_OPTION_FUNCTIONS(type, name)                               \
  m.def("set_global_" #name "_options",                                        \
        [](type const &options) { global_##name##_options = options; });       \
  m.def("get_global_" #name "_options",                                        \
        []() { return global_##name##_options; })

  MAKE_GLOBAL_OPTION_FUNCTIONS(ParseOptions, parse);
  MAKE_GLOBAL_OPTION_FUNCTIONS(PEvaluationOptions, evaluation);
  MAKE_GLOBAL_OPTION_FUNCTIONS(PrintOptions, print);
  MAKE_GLOBAL_OPTION_FUNCTIONS(SortOptions, sort);
}
