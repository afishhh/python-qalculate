#include <cassert>
#include <libqalculate/qalculate.h>
#include <pybind11/attr.h>
#include <pybind11/cast.h>
#include <pybind11/gil.h>
#include <pybind11/operators.h>
#include <pybind11/pybind11.h>
#include <pybind11/pytypes.h>
#include <pybind11/stl.h>
#include <string_view>

#include "expression_items.hh"
#include "generated.hh"
#include "options.hh"
#include "proxies.hh"
#include "pybind.hh"
#include "ref.hh"
#include "wrappers.hh"

Number number_from_python_int(py::int_ value) {
  int overflow;
  long long long_value = PyLong_AsLongLongAndOverflow(value.ptr(), &overflow);
  if (overflow != 0) {
    py::int_ positive;
    if (overflow < 0) {
      PyObject *result = PyNumber_Absolute(value.ptr());
      if (result == nullptr)
        throw py::error_already_set();
      positive = pybind11::reinterpret_steal<py::int_>(result);
    } else
      positive = value;

    auto bytes = positive.attr("to_bytes")(512).cast<py::bytes>();
    auto result = Number();

    for (auto byte : bytes) {
      result.multiply(256);
      result.add(byte.cast<long>());
    }

    if (overflow < 0)
      result.negate();

    return result;
  } else if (PyErr_Occurred())
    throw py::error_already_set();
  else
    return long_value;
}

py::int_ assert_and_steal_int(PyObject *object) {
  assert(object != nullptr);
  return py::reinterpret_steal<py::int_>(object);
}

py::int_ number_to_python_int(Number const &number) {
  if (!number.isInteger())
    throw py::value_error("Non-integer Number cannot be converted into an int");

  {
    bool overflowed = false;
    long value = number.lintValue(&overflowed);
    if (!overflowed)
      return assert_and_steal_int(PyLong_FromLong(value));
  }

  constexpr long int bits = std::numeric_limits<long int>::digits - 1;
  constexpr long int mask = ((long int)1 << bits) - 1;
  std::vector<long int> limbs;

  Number current = number;
  if (current.isNegative())
    assert(current.negate());

  while (current.isNonZero()) {
    Number tmp = current;
    assert(tmp.bitAnd(mask));
    limbs.push_back(tmp.ulintValue());
    assert(current.shiftRight(bits));
  }

  py::int_ pybits = assert_and_steal_int(PyLong_FromLong(bits));
  py::int_ pymask = assert_and_steal_int(PyLong_FromLong(mask));
  py::int_ result = assert_and_steal_int(PyLong_FromLong(limbs.back()));
  limbs.pop_back();

  while (!limbs.empty()) {
    result = assert_and_steal_int(
        PyNumber_InPlaceLshift(result.ptr(), pybits.ptr()));
    py::int_ limb = assert_and_steal_int(PyLong_FromLong(limbs.back()));
    result =
        assert_and_steal_int(PyNumber_InPlaceAdd(result.ptr(), limb.ptr()));
    limbs.pop_back();
  }

  if (number.isNegative())
    result = assert_and_steal_int(PyNumber_Negative(result.ptr()));

  return result;
}

MathStructureRef calculate(MathStructure const &mstruct,
                           PEvaluationOptions const &options, std::string to) {
  MathStructure result;
  {
    py::gil_scoped_release _gil;
    result = CALCULATOR->calculate(mstruct, options, to);
  }
  return MathStructureRef::adopt(result);
}

PYBIND11_MODULE(qalculate, m) {
  m.doc() = "Python bindings for libqalculate";

  new Calculator();

  // TODO: Properties somewhere?
  m.def("get_precision", []() { return CALCULATOR->getPrecision(); });
  m.def("set_precision",
        [](int precision) { CALCULATOR->setPrecision(precision); });

  add_all_enums(m);

#define DEF_COMPARISON_HELPER(name, macro)                                     \
  .def_property_readonly(name,                                                 \
                         [](ComparisonResult self) { return macro(self); })

  // clang-format off
  // Values are defined in add_all_enums
  add_comparison_result_enum(m)
    DEF_COMPARISON_HELPER("might_be_less_or_greater", COMPARISON_MIGHT_BE_LESS_OR_GREATER)
    DEF_COMPARISON_HELPER("not_fully_known", COMPARISON_NOT_FULLY_KNOWN)
    DEF_COMPARISON_HELPER("is_equal_or_greater", COMPARISON_IS_EQUAL_OR_GREATER)
    DEF_COMPARISON_HELPER("is_equal_or_less", COMPARISON_IS_EQUAL_OR_LESS)
    DEF_COMPARISON_HELPER("is_not_equal", COMPARISON_IS_NOT_EQUAL)
    DEF_COMPARISON_HELPER("might_be_equal", COMPARISON_MIGHT_BE_EQUAL)
    DEF_COMPARISON_HELPER("might_be_not_equal", COMPARISON_MIGHT_BE_NOT_EQUAL);
  // clang-format on

  add_sort_options(m);
  add_print_options(m);
  add_parse_options(m);
  // FIXME: isolate_var is not part of the autogenerated constructor
  add_evaluation_options(m).def_property("isolate_var",
                                         &PEvaluationOptions::get_isolate_var,
                                         &PEvaluationOptions::set_isolate_var);

  repr_print_options.use_unicode_signs = UNICODE_SIGNS_WITHOUT_EXPONENTS;

  auto number = add_number_properties(
      py::class_<Number>(m, "Number")
          .def(py::init<>())
          .def(py::init(&number_from_python_int))
          .def(py::init([](long double value) {
            Number number;
            number.setFloat(value);
            return number;
          }))

          .def(
              "print",
              [](Number const &self, PrintOptions const &options) {
                return self.print(options);
              },
              py::arg("options") = &global_print_options, py::pos_only{},
              py::is_operator{})

          .def("__int__",
               [](Number const &self) -> py::int_ {
                 return number_to_python_int(self);
               })

          .def(
              "__repr__",
              [](Number const &self) { return self.print(repr_print_options); },
              py::is_operator{})

          .def(-py::self)

          .def(py::self * py::self)
          .def(py::self *= py::self)
          .def(py::self / py::self)
          .def(decltype(py::self)() /= py::self)
          .def(py::self + py::self)
          .def(py::self += py::self)
          .def(py::self - py::self)
          .def(decltype(py::self)() -= py::self)

          // Number ^ Number is actually exponentiation not a bitwise xor!
          .def(
              "__pow__",
              [](Number const &self, Number const &other) {
                return self ^ other;
              },
              py::is_operator{})
          .def(
              "__ipow__",
              [](Number &self, Number const &other) { self ^= other; },
              py::is_operator{})

          .def(
              "__eq__",
              [](Number const&self, Number const &other) {
                // Compare infinities as equal by default
                return self.equals(other, false, true);
              },
              py::is_operator{})

          .def(py::self < py::self)
          .def(py::self <= py::self)
          .def(py::self > py::self)
          .def(py::self >= py::self));

  py::implicitly_convertible<py::int_, Number>();

  // FIXME: Clean this up finally...
  add_math_structure_proxies(init_math_structure_children(
      m, add_math_structure_operators(
             add_math_structure_methods(add_math_structure_properties(
                 qalc_class_<MathStructure>(m, "MathStructure", py::is_final{})
                     .def("compare", &MathStructure::compare)
                     .def("compare_approximately",
                          &MathStructure::compareApproximately)

                     .def("calculate", &calculate,
                          py::arg("options") = &global_evaluation_options,
                          py::arg("to") = "")

                     .def(
                         "print",
                         [](MathStructure &s, PrintOptions const &options) {
                           return s.print(options);
                         },
                         py::arg("options") = &global_print_options)

                     .def(
                         "__eq__",
                         [](MathStructure const&self, MathStructure const &other) {
                           // Compare infinities as equal by default
                           return self.equals(other, false, true);
                         },
                         py::is_operator{}))))));

  number.def(py::init([](MathStructureNumberProxy const &structure) {
    return structure.number();
  }));

  add_expression_name(m);
  add_expression_item(m);
  add_assumptions(m);
  add_variable(m).def(py::init([](MathStructureVariableProxy const &m) {
                        return QalcRef(m.variable());
                      }),
                      py::arg("math_structure"), py::pos_only{},
                      py::return_value_policy::reference_internal);
  add_unknown_variable(m);
  add_math_function(m);
  add_builtin_functions(m);
  add_unit(m);

  py::implicitly_convertible<Variable, MathStructureVariableProxy>();
  py::implicitly_convertible<MathStructureVariableProxy, Variable>();
  py::implicitly_convertible<MathFunction, MathStructureFunctionProxy>();

  m.def("get_message_print_options",
        []() { return CALCULATOR->messagePrintOptions(); });

  m.def("set_message_print_options",
        [](PrintOptions &opts) { CALCULATOR->setMessagePrintOptions(opts); });

  m.def("calculate", &calculate, py::arg("mstruct"), py::pos_only{},
        py::arg("options") = &global_evaluation_options, py::arg("to") = "");

  m.def(
      "parse",
      [](std::string_view s) {
        return MathStructureRef::adopt(CALCULATOR->parse(std::string(s)));
      },
      py::arg("value"), py::pos_only{});

  m.def(
      "calculate",
      [](std::string expression, PEvaluationOptions const &options,
         std::string to) {
        return calculate(CALCULATOR->parse(expression, options.parse_options),
                         options, to);
      },
      py::arg("mstruct"), py::arg("options") = &global_evaluation_options,
      py::arg("to") = "");

  m.def(
      "calculate_and_print",
      [](std::string expression, PEvaluationOptions const &eval_options,
         PrintOptions const &print_options) {
        py::gil_scoped_release _gil;
        std::string result = CALCULATOR->calculateAndPrint(
            expression, -1, eval_options, print_options);
        assert(!CALCULATOR->aborted());
        return result;
      },
      py::arg("expression"),
      py::arg("eval_options") = &global_evaluation_options,
      py::arg("print_options") = &global_print_options);

  py::class_<CalculatorMessage>(m, "Message")
      .def_property_readonly("text", &CalculatorMessage::c_message)
      .def_property_readonly("type", &CalculatorMessage::type);

  m.def("take_messages", []() {
    std::vector<CalculatorMessage> messages;
    while (true) {
      CalculatorMessage *msg = CALCULATOR->message();
      if (!msg)
        return messages;
      messages.emplace_back(std::move(*msg));
      CALCULATOR->nextMessage();
    }
  });

  auto loaders =
      std::initializer_list<std::pair<char const *, bool (Calculator::*)()>>{
          {"load_global_prefixes", &Calculator::loadGlobalPrefixes},
          {"load_global_currencies", &Calculator::loadGlobalCurrencies},
          {"load_global_units", &Calculator::loadGlobalUnits},
          {"load_global_variables", &Calculator::loadGlobalVariables},
          {"load_global_functions", &Calculator::loadGlobalFunctions},
          {"load_global_dataSets", &Calculator::loadGlobalDataSets},
      };
  for (auto loader : loaders)
    m.def(loader.first, [loader] {
      if (!(*CALCULATOR.*loader.second)())
        throw std::runtime_error("qalculate failed to load something");
    });

#define MAKE_GLOBAL_OPTION_FUNCTIONS(type, name)                               \
  m.def("set_global_" #name "_options",                                        \
        [](type const &options) { global_##name##_options = options; });       \
  m.def("get_global_" #name "_options",                                        \
        []() { return global_##name##_options; })

  MAKE_GLOBAL_OPTION_FUNCTIONS(ParseOptions, parse);
  MAKE_GLOBAL_OPTION_FUNCTIONS(PEvaluationOptions, evaluation);
  MAKE_GLOBAL_OPTION_FUNCTIONS(PrintOptions, print);
  MAKE_GLOBAL_OPTION_FUNCTIONS(SortOptions, sort);
}
